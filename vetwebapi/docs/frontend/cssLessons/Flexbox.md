# FLEXBOX

Справочная информация
Модуль Flexbox Layout (Flexible Box) (рекомендация для кандидатов в W3C по состоянию на октябрь 2017 года) направлен на предоставление более эффективного способа размещения, выравнивания и распределения пространства между элементами в контейнере, даже если их размер неизвестен и / или динамичен (отсюда и слово “гибкий”).

Основная идея гибкого макета заключается в том, чтобы предоставить контейнеру возможность изменять ширину / высоту (и порядок) своих элементов, чтобы наилучшим образом заполнить доступное пространство (в основном для размещения на всех типах устройств отображения и размерах экрана). Гибкий контейнер расширяет элементы, чтобы заполнить доступное свободное пространство, или сжимает их, чтобы предотвратить переполнение.

Самое главное, что макет flexbox не зависит от направления, в отличие от обычных макетов (блочный, который основан по вертикали, и встроенный, который основан по горизонтали). Хотя они хорошо работают для страниц, им не хватает гибкости (не хочу каламбурить) для поддержки больших или сложных приложений (особенно когда дело доходит до изменения ориентации, размера, растяжения, сжатия и т.д.).

Примечание: Макет Flexbox наиболее подходит для компонентов приложения и макетов небольшого масштаба, в то время как макет Grid предназначен для макетов большего масштаба.

## Основы и терминология
Поскольку flexbox - это целый модуль, а не отдельное свойство, он включает в себя множество вещей, включая весь его набор свойств. Некоторые из них предназначены для установки в контейнере (родительский элемент, известный как “гибкий контейнер”), тогда как другие предназначены для установки в дочерних элементах (так называемые “гибкие элементы”).

Если ”обычная" верстка основана как на блочных, так и на встроенных направлениях потока, то гибкая верстка основана на "направлениях гибкого потока”. Пожалуйста, взгляните на этот рисунок из спецификации, объясняющий основную идею, лежащую в основе гибкого макета.

Диаграмма, объясняющая терминологию flexbox. Размер по главной оси flexbox называется основным размером, в другом направлении - поперечным размером. Эти размеры имеют главное начало, главный конец, перекрестное начало и перекрестный конец.
Элементы будут располагаться либо по main axis (от main-start до main-end), либо по поперечной оси (от cross-start до cross-end).

главная ось – Главная ось контейнера flex - это основная ось, вдоль которой располагаются элементы flex. Будьте осторожны, он не обязательно горизонтальный; это зависит от flex-direction свойства (см. Ниже).
main-start | main-end – Элементы flex размещаются внутри контейнера, начиная с main-start и заканчивая main-end.
Основной размер – Ширина или высота элемента flex, в зависимости от того, что находится в основном измерении, является основным размером элемента. Основным свойством размера элемента flex является свойство ‘width’ или ‘height’, в зависимости от того, что находится в основном размере.
поперечная ось – ось, перпендикулярная главной оси, называется поперечной осью. Ее направление зависит от направления главной оси.
перекрестные | сквозные линии Flex заполняются элементами и помещаются в контейнер, начиная со стороны перекрестного начала контейнера flex и направляясь к стороне перекрестного конца.
поперечный размер – ширина или высота элемента flex, в зависимости от того, что находится в поперечном измерении, является поперечным размером элемента. Свойство cross size зависит от того, какое из значений ‘width’ или ‘height’ находится в поперечном измерении.

## отобразить
Это определяет контейнер flex; встроенный или блочный в зависимости от заданного значения. Это позволяет использовать контекст flex для всех его прямых дочерних элементов.

```css
.container {
  display: flex; /* or inline-flex */
}

```

Обратите внимание, что столбцы CSS никак не влияют на контейнер flex.

## flex-direction
показаны четыре возможных значения flex-direction: сверху вниз, снизу вверх, справа налево и слева направо

Это устанавливает главную ось, таким образом определяя направление, в котором элементы flex размещаются в контейнере flex. Flexbox (помимо необязательной упаковки) представляет собой концепцию однонаправленного макета. Представьте, что элементы flex в основном располагаются либо горизонтальными рядами, либо вертикальными столбцами.

```css
.container {
  flex-direction: row | row-reverse | column | column-reverse;
}
```

row (по умолчанию): слева направо в ltr; справа налево в rtl

row-reverse: справа налево в ltr; слева направо в rtl

column: то же, что и row, но сверху вниз

column-reverse: то же, что и row-reverse, но снизу вверх

## flex-wrap
два ряда коробок, первый переходящий во второй
По умолчанию все элементы flex будут пытаться поместиться в одну строку. Вы можете изменить это и разрешить перенос элементов по мере необходимости с помощью этого свойства.

```css
.container {
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```


nowrap (по умолчанию): все элементы flex будут располагаться в одной строке

wrap: элементы flex будут переноситься в несколько строк сверху вниз.

wrap-reverse: элементы flex будут переноситься в несколько строк снизу вверх.

## flex-flow
Это сокращение для свойств flex-direction и flex-wrap, которые вместе определяют главную и поперечную оси контейнера flex. Значение по умолчанию - row nowrap.
```css
.container {
  flex-flow: column wrap;
}
```

## justify-content

Это определяет выравнивание по главной оси. Это помогает распределить дополнительное свободное пространство, оставшееся, когда либо все элементы flex в строке негибкие, либо они гибкие, но достигли своего максимального размера. Он также предоставляет некоторый контроль над выравниванием элементов, когда они выходят за пределы строки.

```css
.container {
  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;
}
```
flex-start (по умолчанию): элементы упаковываются в начале гибкого направления.

flex-end: элементы упаковываются ближе к концу гибкого направления.

start: элементы упаковываются в начале writing-mode направления.

end: элементы упаковываются ближе к концу writing-mode направления.

left: элементы упаковываются к левому краю контейнера, если это не имеет 
смысла для flex-direction, тогда он ведет себя следующим образом start.

right: элементы упаковываются к правому краю контейнера, если это не имеет смысла для flex-direction, тогда он ведет себя следующим образом end.

center: элементы располагаются по центру вдоль линии

space-between: элементы равномерно распределены в строке; первый элемент находится в начальной строке, последний элемент - в конечной строке

space-around: элементы равномерно распределены по линии с равным пространством вокруг них. Обратите внимание, что визуально пробелы неравны, поскольку у всех элементов одинаковое пространство с обеих сторон. У первого элемента будет одна единица пространства у края контейнера, но две единицы пространства между следующим элементом, потому что у следующего элемента есть свой интервал, который применяется.

space-evenly: элементы распределяются таким образом, чтобы расстояние между любыми двумя элементами (и расстояние до краев) было одинаковым.
Обратите внимание, что поддержка браузером этих значений имеет свои нюансы. Например, space-between никогда не получал поддержки от некоторых версий Edge, а start / end / left / right еще нет в Chrome. В MDN есть подробные диаграммы. Самые безопасные значения - это flex-start, flex-end и center.

Есть также два дополнительных ключевых слова, которые вы можете связать с этими значениями: safe и unsafe. Использование safe гарантирует, что, как бы вы ни позиционировали этот тип, вы не сможете переместить элемент так, чтобы он отображался за пределами экрана (например, сверху), таким образом, содержимое также не может прокручиваться (это называется “потерей данных”).

## align-items
Это определяет поведение по умолчанию для размещения элементов flex вдоль поперечной оси на текущей линии. Думайте об этом как о justify-content версии для поперечной оси (перпендикулярной главной оси).

```css
.container {
  align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;
}
```
stretch (по умолчанию): растягивать, чтобы заполнить контейнер (по-прежнему соблюдая минимальную ширину / максимальную ширину)

flex-start / start / self-start: элементы размещаются в начале поперечной оси. Разница между ними неуловима и заключается в соблюдении 

flex-direction правил или в writing-mode предписаниях.

flex-end / end / self-end: элементы размещаются в конце поперечной оси. Разница, опять же, неуловима и заключается в соблюдении flex-direction правил по сравнению с writing-mode rules.

center: элементы центрируются по поперечной оси

baseline: элементы выравниваются так, как выравниваются их базовые линии

Ключевые слова-модификаторы safe и unsafe могут использоваться в сочетании со всеми остальными ключевыми словами (хотя обратите внимание на поддержку браузера) и помогают предотвратить выравнивание элементов таким образом, чтобы содержимое становилось недоступным.

## align-content

Это позволяет выравнивать линии контейнера flex внутри, когда на поперечной оси остается лишнее пространство, аналогично тому, как justify-content выравнивает отдельные элементы внутри главной оси.

Примечание: Это свойство вступает в силу только для многострочных гибких контейнеров, где flex-wrap установлено значение или wrap или wrap-reverse). Однострочный гибкий контейнер (т. Е. Где flex-wrap установлено значение по умолчанию, no-wrap) не будет отражать align-content.

```css
.container {
  align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;
}
```
normal (по умолчанию): элементы упаковываются в положение по умолчанию, как если бы значение не было задано.

flex-start / start: элементы, упакованные в начале контейнера. (Более поддерживается) flex-start соблюдаетflex-direction, в то время как start соблюдает writing-mode направление.

flex-end / end: элементы упаковываются до конца контейнера. (Дополнительная поддержка) flex-end соблюдаетflex-direction, а end соблюдает writing-mode направление.

center: элементы, размещенные по центру контейнера

space-between: элементы распределены равномерно; первая строка находится в начале контейнера, а последняя - в конце

space-around: элементы равномерно распределены с равным пространством вокруг каждой строки

space-evenly: элементы равномерно распределены с равным пространством вокруг них

stretch: линии растягиваются, занимая оставшееся пространство

Ключевые слова-модификаторы safe и unsafe могут использоваться в сочетании со всеми остальными ключевыми словами (хотя обратите внимание на поддержку браузера) и помогают предотвратить выравнивание элементов таким образом, чтобы содержимое становилось недоступным.

## gapСвойство 
явно управляет расстоянием между элементами flex. Это расстояние применяется только между элементами, а не по внешним краям.

```css
.container {
  display: flex;
  ...
  gap: 10px;
  gap: 10px 20px; /* row-gap column gap */
  row-gap: 10px;
  column-gap: 20px;
}
```
Поведение можно рассматривать как минимальный желоб, как будто желоб каким-то образом больше (из-за чего-то вроде justify-content: space-between;), тогда разрыв вступит в силу только в том случае, если это пространство в конечном итоге станет меньше.

Оно предназначено не только для flexbox, gap также работает в сетке и с многостолбцовым макетом.


## Примеры
Давайте начнем с очень-очень простого примера решения почти повседневной проблемы: идеального центрирования. Ничего не может быть проще, если вы используете flexbox.

```css
.parent {
  display: flex;
  height: 300px; /* Or whatever */
}

.child {
  width: 100px;  /* Or whatever */
  height: 100px; /* Or whatever */
  margin: auto;  /* Magic! */
}
```
Это основано на том факте, что поле, установленное на auto в контейнере flex, занимает дополнительное пространство. Таким образом, установка поля на auto сделает элемент идеально центрированным по обеим осям.

Теперь давайте воспользуемся еще некоторыми свойствами. Рассмотрим список из 6 элементов, все с фиксированными размерами, но могут иметь автоматический размер. Мы хотим, чтобы они были равномерно распределены по горизонтальной оси, чтобы при изменении размера браузера все масштабировалось красиво и без медиазапросов.

```css
.flex-container {
  /* We first create a flex layout context */
  display: flex;

  /* Then we define the flow direction 
     and if we allow the items to wrap 
   * Remember this is the same as:
   * flex-direction: row;
   * flex-wrap: wrap;
   */
  flex-flow: row wrap;

  /* Then we define how is distributed the remaining space */
  justify-content: space-around;
}
```
Выполнено. Все остальное зависит от стиля. Ниже приведена ручка с этим примером. Обязательно зайдите в CodePen и попробуйте изменить размер windows, чтобы посмотреть, что получится.

Давайте попробуем что-нибудь еще. Представьте, что у нас есть элемент навигации, выровненный по правому краю, в самом верху нашего веб-сайта, но мы хотим, чтобы он располагался по центру на экранах среднего размера и состоял из одной колонки на небольших устройствах. Достаточно просто.
```css
/* Large */
.navigation {
  display: flex;
  flex-flow: row wrap;
  /* This aligns items to the end line on main-axis */
  justify-content: flex-end;
}

/* Medium screens */
@media all and (max-width: 800px) {
  .navigation {
    /* When on medium sized screens, we center it by evenly distributing empty space around items */
    justify-content: space-around;
  }
}

/* Small screens */
@media all and (max-width: 500px) {
  .navigation {
    /* On small screens, we are no longer using row direction but column */
    flex-direction: column;
  }
}
```
Давайте попробуем кое-что еще лучше, поиграв с гибкостью элементов flex! Как насчет макета из 3 столбцов для мобильных устройств с верхним и нижним колонтитулами во всю ширину. И независимым от исходного кода порядком.

```css
.wrapper {
  display: flex;
  flex-flow: row wrap;
}

/* We tell all items to be 100% width, via flex-basis */
.wrapper > * {
  flex: 1 100%;
}

/* We rely on source order for mobile-first approach
 * in this case:
 * 1. header
 * 2. article
 * 3. aside 1
 * 4. aside 2
 * 5. footer
 */

/* Medium screens */
@media all and (min-width: 600px) {
  /* We tell both sidebars to share a row */
  .aside { flex: 1 auto; }
}

/* Large screens */
@media all and (min-width: 800px) {
  /* We invert order of first sidebar and main
   * And tell the main element to take twice as much width as the other two sidebars 
   */
  .main { flex: 3 0px; }
  .aside-1 { order: 1; }
  .main    { order: 2; }
  .aside-2 { order: 3; }
  .footer  { order: 4; }
}
```
